// Local type definitions to avoid import issues
type Client = {
  ClientId: string;
  ClientName: string;
  PriorityLevel: number;
  RequestedTaskIDs: string[];
  GroupTag: string;
  AttributesJSON: string;
};

type WorkerData = {
  WorkerID: string;
  WorkerName: string;
  Skills: string[];
  AvailableSlots: number[];
  MaxLoadPerPhase: number;
  WorkerGroup: string;
  QualificationLevel: number;
};

type Task = {
  TaskID: string;
  TaskName: string;
  Category: string;
  Duration: number;
  RequiredSkills: string[];
  PreferredPhases: number[];
  MaxConcurrent: number;
  CoRunGroups?: string[]; // Tasks that must run together
  Dependencies?: string[]; // Tasks that must run before this one
};

// ERROR

export interface ValidationError {
  row: number;
  column: string;
  message: string;
  type: "error" | "warning" | "critical";
  entityType: "client" | "worker" | "task" | "system";
  severity: 1 | 2 | 3 | 4 | 5; // 1=info, 5=critical
  aiGenerated?: boolean; // Whether this error was generated by AI
  confidence?: number; // AI confidence score (0-1)
}

// SUMMARY
export interface ValidationSummary {
  totalErrors: number;
  totalWarnings: number;
  totalCritical: number;
  errorsByEntity: Record<string, number>;
  errorsByType: Record<string, number>;
  validationScore: number; // 0-100, higher is better
  canProceed: boolean; // Whether system can operate with current data
}

// THE MAIN ENGINE
export class ValidationEngine {
  private clients: Client[] = [];
  private workers: WorkerData[] = [];
  private tasks: Task[] = [];

  setData(clients: Client[], workers: WorkerData[], tasks: Task[]) {
    this.clients = clients;
    this.workers = workers;
    this.tasks = tasks;
  }

  validateAll(): { errors: ValidationError[]; summary: ValidationSummary } {
    const errors: ValidationError[] = [];

    console.log("Running comprehensive validation with 12 advanced rules...");

    // Core entity validations (Rules 1-5)
    errors.push(...this.validateClients());
    errors.push(...this.validateWorkers());
    errors.push(...this.validateTasks());

    // Advanced cross-entity validations (Rules 6-12)
    errors.push(...this.validateCrossEntityReferences());
    errors.push(...this.validateCircularDependencies());
    errors.push(...this.validateTaskDurationVsPhases());
    errors.push(...this.validateWorkerPhaseOverload());
    errors.push(...this.validatePhaseSlotSaturation());
    errors.push(...this.validateSkillCoverageMatrix());
    errors.push(...this.validateMaxConcurrencyFeasibility());
    errors.push(...this.validateResourceAllocation());


    const summary = this.generateAdvancedSummary(errors);

    console.log(`âœ… Validation complete: ${errors.length} issues found`);
    console.log(`ðŸ“Š Validation Score: ${summary.validationScore}/100`);

    return { errors, summary };
  }

  // RULE 1-2: Missing required columns & Duplicate IDs
  private validateClients(): ValidationError[] {
    const errors: ValidationError[] = [];
    const clientIds = new Set<string>();
    const requiredColumns = ["ClientId", "ClientName", "PriorityLevel"];

    this.clients.forEach((client, index) => {
      // Required columns check
      requiredColumns.forEach((column) => {
        if (!client[column as keyof Client]) {
          errors.push({
            row: index,
            column,
            message: `Required column "${column}" is missing or empty`,
            type: "critical",
            entityType: "client",
            severity: 5,
          });
        }
      });

      // Duplicate ID check
      if (client.ClientId) {
        if (clientIds.has(client.ClientId)) {
          errors.push({
            row: index,
            column: "ClientId",
            message: `Duplicate ClientID "${client.ClientId}" found`,
            type: "critical",
            entityType: "client",
            severity: 5,
          });
        } else {
          clientIds.add(client.ClientId);
        }
      }

      // RULE 4: Out-of-range values (PriorityLevel 1-5)
      if (
        client.PriorityLevel &&
        (client.PriorityLevel < 1 || client.PriorityLevel > 5)
      ) {
        errors.push({
          row: index,
          column: "PriorityLevel",
          message: `PriorityLevel must be between 1 and 5, got ${client.PriorityLevel}`,
          type: "error",
          entityType: "client",
          severity: 3,
        });
      }

      // RULE 5: Broken JSON in AttributesJSON
      if (client.AttributesJSON) {
        try {
          JSON.parse(client.AttributesJSON);
        } catch (jsonError) {
          errors.push({
            row: index,
            column: "AttributesJSON",
            message: "Invalid JSON format in AttributesJSON",
            type: "error",
            entityType: "client",
            severity: 3,
          });
        }
      }

      // RULE 3: Malformed lists (RequestedTaskIDs)
      if (client.RequestedTaskIDs && !Array.isArray(client.RequestedTaskIDs)) {
        errors.push({
          row: index,
          column: "RequestedTaskIDs",
          message: "RequestedTaskIDs must be an array",
          type: "error",
          entityType: "client",
          severity: 3,
        });
      }
    });

    return errors;
  }

  private validateWorkers(): ValidationError[] {
    const errors: ValidationError[] = [];
    const workerIds = new Set<string>();
    const requiredColumns = [
      "WorkerID",
      "WorkerName",
      "Skills",
      "AvailableSlots",
      "MaxLoadPerPhase",
    ];

    this.workers.forEach((worker, index) => {
      // Required columns check
      requiredColumns.forEach((column) => {
        if (!worker[column as keyof WorkerData]) {
          errors.push({
            row: index,
            column,
            message: `Required column "${column}" is missing or empty`,
            type: "critical",
            entityType: "worker",
            severity: 5,
          });
        }
      });

      // Duplicate ID check
      if (worker.WorkerID) {
        if (workerIds.has(worker.WorkerID)) {
          errors.push({
            row: index,
            column: "WorkerID",
            message: `Duplicate WorkerID "${worker.WorkerID}" found`,
            type: "critical",
            entityType: "worker",
            severity: 5,
          });
        } else {
          workerIds.add(worker.WorkerID);
        }
      }

      // RULE 3: Malformed lists (AvailableSlots must be numeric)
      const availableSlots = Array.isArray(worker.AvailableSlots)
        ? worker.AvailableSlots
        : [];
      if (
        availableSlots.some(
          (slot: any) => isNaN(Number(slot)) || Number(slot) < 1
        )
      ) {
        errors.push({
          row: index,
          column: "AvailableSlots",
          message: "AvailableSlots must contain valid positive numbers only",
          type: "error",
          entityType: "worker",
          severity: 4,
        });
      }

      // RULE 9: Overloaded workers (AvailableSlots.length < MaxLoadPerPhase)
      if (
        availableSlots.length > 0 &&
        worker.MaxLoadPerPhase > availableSlots.length
      ) {
        errors.push({
          row: index,
          column: "MaxLoadPerPhase",
          message: `MaxLoadPerPhase (${worker.MaxLoadPerPhase}) cannot exceed AvailableSlots count (${availableSlots.length})`,
          type: "error",
          entityType: "worker",
          severity: 4,
        });
      }

      // Qualification level validation
      if (
        worker.QualificationLevel &&
        (worker.QualificationLevel < 1 || worker.QualificationLevel > 10)
      ) {
        errors.push({
          row: index,
          column: "QualificationLevel",
          message: "QualificationLevel must be between 1 and 10",
          type: "warning",
          entityType: "worker",
          severity: 2,
        });
      }
    });

    return errors;
  }

  private validateTasks(): ValidationError[] {
    const errors: ValidationError[] = [];
    const taskIds = new Set<string>();
    const requiredColumns = [
      "TaskID",
      "TaskName",
      "Duration",
      "RequiredSkills",
    ];

    this.tasks.forEach((task, index) => {
      // Required columns check
      requiredColumns.forEach((column) => {
        if (!task[column as keyof Task]) {
          errors.push({
            row: index,
            column,
            message: `Required column "${column}" is missing or empty`,
            type: "critical",
            entityType: "task",
            severity: 5,
          });
        }
      });

      // Duplicate ID check
      if (task.TaskID) {
        if (taskIds.has(task.TaskID)) {
          errors.push({
            row: index,
            column: "TaskID",
            message: `Duplicate TaskID "${task.TaskID}" found`,
            type: "critical",
            entityType: "task",
            severity: 5,
          });
        } else {
          taskIds.add(task.TaskID);
        }
      }

      // RULE 4: Out-of-range values (Duration < 1)
      if (task.Duration && task.Duration < 1) {
        errors.push({
          row: index,
          column: "Duration",
          message: `Duration must be at least 1, got ${task.Duration}`,
          type: "error",
          entityType: "task",
          severity: 4,
        });
      }

      // MaxConcurrent validation
      if (task.MaxConcurrent && task.MaxConcurrent < 1) {
        errors.push({
          row: index,
          column: "MaxConcurrent",
          message: "MaxConcurrent must be at least 1",
          type: "error",
          entityType: "task",
          severity: 3,
        });
      }

      // RULE 3: Malformed lists validation
      if (task.RequiredSkills && !Array.isArray(task.RequiredSkills)) {
        errors.push({
          row: index,
          column: "RequiredSkills",
          message: "RequiredSkills must be an array",
          type: "error",
          entityType: "task",
          severity: 3,
        });
      }

      if (task.PreferredPhases && !Array.isArray(task.PreferredPhases)) {
        errors.push({
          row: index,
          column: "PreferredPhases",
          message: "PreferredPhases must be an array",
          type: "error",
          entityType: "task",
          severity: 3,
        });
      }
    });

    return errors;
  }

  // RULE 6: Unknown references (RequestedTaskIDs not in tasks; regex rules referencing missing TaskIDs)
  // private validateCrossEntityReferences(): ValidationError[] {
  //     const errors: ValidationError[] = [];
  //     const taskIds = new Set(this.tasks.map(t => t.TaskID).filter(Boolean));

  //     // Check client RequestedTaskIDs references
  //     this.clients.forEach((client, index) => {
  //         const requestedTaskIDs = Array.isArray(client.RequestedTaskIDs) ? client.RequestedTaskIDs : [];

  //         requestedTaskIDs.forEach((taskId: string) => {
  //             if (taskId && !taskIds.has(taskId)) {
  //                 errors.push({
  //                     row: index,
  //                     column: 'RequestedTaskIDs',
  //                     message: `Referenced TaskID "${taskId}" not found in tasks dataset`,
  //                     type: 'error',
  //                     entityType: 'client',
  //                     severity: 4
  //                 });
  //             }
  //         });
  //     });

  //     // Check task dependencies references
  //     this.tasks.forEach((task, index) => {
  //         if (task.Dependencies && Array.isArray(task.Dependencies)) {
  //             task.Dependencies.forEach((depTaskId: string) => {
  //                 if (depTaskId && !taskIds.has(depTaskId)) {
  //                     errors.push({
  //                         row: index,
  //                         column: 'Dependencies',
  //                         message: `Dependency TaskID "${depTaskId}" not found in tasks dataset`,
  //                         type: 'error',
  //                         entityType: 'task',
  //                         severity: 4
  //                     });
  //                 }
  //             });
  //         }
  //     });

  //     return errors;
  // }
  private validateCrossEntityReferences(): ValidationError[] {
    const errors: ValidationError[] = [];
    const taskIds = new Set(this.tasks.map((t) => t.TaskID));

    // Clients â†’ Tasks
    this.clients.forEach((client, row) => {
      (client.RequestedTaskIDs || []) // guard missing / empty
        .filter((id) => !taskIds.has(id))
        .forEach((id) => {
          errors.push({
            row,
            column: "RequestedTaskIDs",
            message: `Task "${id}" not found`,
            type: "error",
            entityType: "client",
            severity: 4,
          });
        });
    });

    // Tasks â†’ Dependencies
    this.tasks.forEach((task, row) => {
      (task.Dependencies || [])
        .filter((dep) => !taskIds.has(dep))
        .forEach((badDep) => {
          errors.push({
            row,
            column: "Dependencies",
            message: `Dependency "${badDep}" not found`,
            type: "error",
            entityType: "task",
            severity: 4,
          });
        });
    });

    return errors;
  }

  // RULE 7: Check for circular task dependencies (Aâ†’Bâ†’Câ†’A) 
  // Note: Cycle detection requires proper DFS algorithm - complexity is necessary
  private validateCircularDependencies(): ValidationError[] {
    const errors: ValidationError[] = [];

    // Build dependency map
    const deps: Record<string, string[]> = {};
    this.tasks.forEach(task => {
      if (task.TaskID && task.Dependencies?.length) {
        deps[task.TaskID] = task.Dependencies.filter(Boolean);
      }
    });

    const visiting = new Set<string>();
    const visited = new Set<string>();

    const findCycle = (taskId: string, path: string[]): boolean => {
      if (visiting.has(taskId)) {
        const cycleIndex = path.indexOf(taskId);
        const cycle = [...path.slice(cycleIndex), taskId];
        const taskIndex = this.tasks.findIndex(t => t.TaskID === taskId);
        errors.push({
          row: taskIndex,
          column: "Dependencies",
          message: `Circular dependency: ${cycle.join(" â†’ ")}`,
          type: "critical",
          entityType: "task", 
          severity: 5,
        });
        return true;
      }

      if (visited.has(taskId)) return false;

      visiting.add(taskId);
      const dependencies = deps[taskId] || [];
      
      for (const dep of dependencies) {
        if (findCycle(dep, [...path, taskId])) return true;
      }

      visiting.delete(taskId);
      visited.add(taskId);
      return false;
    };

    // Check all tasks
    Object.keys(deps).forEach(taskId => {
      if (!visited.has(taskId)) {
        findCycle(taskId, []);
      }
    });

    return errors;
  }

  // RULE 8A: Check if task duration fits in preferred phase window
  private validateTaskDurationVsPhases(): ValidationError[] {
    const errors: ValidationError[] = [];

    this.tasks.forEach((task, taskIndex) => {
      const phases = task.PreferredPhases || [];
      const duration = task.Duration || 0;

      if (phases.length > 0 && duration > 0) {
        const phaseSpan = Math.max(...phases) - Math.min(...phases) + 1;
        
        if (duration > phaseSpan) {
          errors.push({
            row: taskIndex,
            column: "Duration",
            message: `Duration ${duration} > phase span ${phaseSpan} (phases: ${phases.join(", ")})`,
            type: "warning", 
            entityType: "task",
            severity: 3,
          });
        }
      }
    });

    return errors;
  }

  // RULE 8B: Check if workers might be overloaded in specific phases
  private validateWorkerPhaseOverload(): ValidationError[] {
    const errors: ValidationError[] = [];

    // Count tasks per phase
    const tasksPerPhase: Record<number, number> = {};
    this.tasks.forEach(task => {
      (task.PreferredPhases || []).forEach(phase => {
        tasksPerPhase[phase] = (tasksPerPhase[phase] || 0) + 1;
      });
    });

    // Check each worker's capacity
    this.workers.forEach((worker, workerIndex) => {
      (worker.AvailableSlots || []).forEach(phase => {
        const taskCount = tasksPerPhase[phase] || 0;
        if (taskCount > worker.MaxLoadPerPhase) {
          errors.push({
            row: workerIndex,
            column: "MaxLoadPerPhase",
            message: `Worker "${worker.WorkerID}" phase ${phase}: ${taskCount} tasks > ${worker.MaxLoadPerPhase} max load`,
            type: "warning",
            entityType: "worker", 
            severity: 2,
          });
        }
      });
    });

    return errors;
  }

  // RULE 10: Check if phases have enough worker capacity for task demand
  private validatePhaseSlotSaturation(): ValidationError[] {
    const errors: ValidationError[] = [];

    // Get all unique phases from workers and tasks
    const allPhases = new Set<number>();
    this.workers.forEach(w => (w.AvailableSlots || []).forEach(p => allPhases.add(p)));
    this.tasks.forEach(t => (t.PreferredPhases || []).forEach(p => allPhases.add(p)));

    allPhases.forEach(phase => {
      // Count worker capacity for this phase
      const workerCapacity = this.workers
        .filter(w => (w.AvailableSlots || []).includes(phase))
        .reduce((sum, w) => sum + w.MaxLoadPerPhase, 0);

      // Count tasks wanting this phase
      const taskDemand = this.tasks
        .filter(t => (t.PreferredPhases || []).includes(phase)).length;

      if (taskDemand > workerCapacity) {
        errors.push({
          row: -1,
          column: "Phase Planning",
          message: `Phase ${phase}: ${taskDemand} tasks want it but only ${workerCapacity} worker slots available`,
          type: "critical",
          entityType: "system",
          severity: 5,
        });
      }
    });

    return errors;
  }

  // RULE 11: Check if workers exist for each required skill
  private validateSkillCoverageMatrix(): ValidationError[] {
    const errors: ValidationError[] = [];

    this.tasks.forEach((task, taskIndex) => {
      const neededSkills = task.RequiredSkills || [];

      neededSkills.forEach((skill: string) => {
        if (!skill) return; // Skip empty skills

        // Count workers who have this skill
        const workersWithSkill = this.workers.filter(worker => 
          (worker.Skills || []).includes(skill)
        ).length;

        if (workersWithSkill === 0) {
          errors.push({
            row: taskIndex,
            column: "RequiredSkills",
            message: `No worker has skill "${skill}"`,
            type: "critical",
            entityType: "task",
            severity: 5,
          });
        } else if (workersWithSkill === 1) {
          errors.push({
            row: taskIndex,
            column: "RequiredSkills", 
            message: `Only 1 worker has skill "${skill}" - bottleneck risk`,
            type: "warning",
            entityType: "task",
            severity: 2,
          });
        }
      });
    });

    return errors;
  }

  // RULE 12: Check if enough skilled workers exist for concurrent task execution
  private validateMaxConcurrencyFeasibility(): ValidationError[] {
    const errors: ValidationError[] = [];

    this.tasks.forEach((task, taskIndex) => {
      const neededSkills = task.RequiredSkills || [];
      const wantedConcurrency = task.MaxConcurrent || 1;

      if (neededSkills.length === 0) return; // Skip tasks with no skill requirements

      // Count workers who have ALL required skills
      const qualifiedWorkerCount = this.workers.filter(worker => {
        const workerSkills = worker.Skills || [];
        return neededSkills.every(skill => workerSkills.includes(skill));
      }).length;

      // Check: Can we run this many concurrent instances?
      if (wantedConcurrency > qualifiedWorkerCount) {
        errors.push({
          row: taskIndex,
          column: "MaxConcurrent",
          message: `Want ${wantedConcurrency} concurrent but only ${qualifiedWorkerCount} workers have skills: ${neededSkills.join(", ")}`,
          type: "error",
          entityType: "task",
          severity: 4,
        });
      }
    });

    return errors;
  }

  // Additional validation for resource allocation
  private validateResourceAllocation(): ValidationError[] {
    const errors: ValidationError[] = [];

    // Check overall system capacity
    const totalWorkerCapacity = this.workers.reduce((sum, worker) => {
      const slots = Array.isArray(worker.AvailableSlots)
        ? worker.AvailableSlots.length
        : 0;
      return sum + slots * worker.MaxLoadPerPhase;
    }, 0);

    const totalTaskLoad = this.tasks.reduce((sum, task) => {
      return sum + (task.Duration || 0) * (task.MaxConcurrent || 1);
    }, 0);

    if (totalTaskLoad > totalWorkerCapacity * 0.9) {
      // 90% threshold
      errors.push({
        row: -1,
        column: "System Capacity",
        message: `System approaching capacity limits: ${totalTaskLoad} task-load vs ${totalWorkerCapacity} worker-capacity`,
        type: "warning",
        entityType: "system",
        severity: 3,
      });
    }

    return errors;
  }

  private generateAdvancedSummary(
    errors: ValidationError[]
  ): ValidationSummary {
    const criticalCount = errors.filter((e) => e.type === "critical").length;
    const errorCount = errors.filter((e) => e.type === "error").length;
    const warningCount = errors.filter((e) => e.type === "warning").length;

    // Calculate validation score (0-100)
    const totalDataPoints =
      this.clients.length + this.workers.length + this.tasks.length;
    const maxPossibleIssues = totalDataPoints * 3; // Assume max 3 issues per data point
    const actualIssues = criticalCount * 3 + errorCount * 2 + warningCount * 1; // Weighted
    const validationScore = Math.max(
      0,
      Math.round(100 - (actualIssues / maxPossibleIssues) * 100)
    );

    const summary: ValidationSummary = {
      totalErrors: errorCount,
      totalWarnings: warningCount,
      totalCritical: criticalCount,
      errorsByEntity: {},
      errorsByType: {
        critical: criticalCount,
        error: errorCount,
        warning: warningCount,
      },
      validationScore,
      canProceed: criticalCount === 0 && errorCount < 5, // System can proceed if no critical errors and few errors
    };

    // Count by entity
    errors.forEach((error) => {
      summary.errorsByEntity[error.entityType] =
        (summary.errorsByEntity[error.entityType] || 0) + 1;
    });

    return summary;
  }

}
