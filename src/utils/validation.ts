// Local type definitions to avoid import issues
type Client = {
  ClientId: string;
  ClientName: string;
  PriorityLevel: number;
  RequestedTaskIDs: string[];
  GroupTag: string;
  AttributesJSON: string;
};

type WorkerData = {
  WorkerID: string;
  WorkerName: string;
  Skills: string[];
  AvailableSlots: number[];
  MaxLoadPerPhase: number;
  WorkerGroup: string;
  QualificationLevel: number;
};

type Task = {
  TaskID: string;
  TaskName: string;
  Category: string;
  Duration: number;
  RequiredSkills: string[];
  PreferredPhases: number[];
  MaxConcurrent: number;
  CoRunGroups?: string[]; // Tasks that must run together
  Dependencies?: string[]; // Tasks that must run before this one
};

// ERROR

export interface ValidationError {
  row: number;
  column: string;
  message: string;
  type: "error" | "warning" | "critical";
  entityType: "client" | "worker" | "task" | "system";
  severity: 1 | 2 | 3 | 4 | 5; // 1=info, 5=critical
  aiGenerated?: boolean; // Whether this error was generated by AI
  confidence?: number; // AI confidence score (0-1)
}

// SUMMARY
export interface ValidationSummary {
  totalErrors: number;
  totalWarnings: number;
  totalCritical: number;
  errorsByEntity: Record<string, number>;
  errorsByType: Record<string, number>;
  validationScore: number; // 0-100, higher is better
  canProceed: boolean; // Whether system can operate with current data
}

// THE MAIN ENGINE
export class ValidationEngine {
  private clients: Client[] = [];
  private workers: WorkerData[] = [];
  private tasks: Task[] = [];

  setData(clients: Client[], workers: WorkerData[], tasks: Task[]) {
    this.clients = clients;
    this.workers = workers;
    this.tasks = tasks;
  }

  validateAll(): { errors: ValidationError[]; summary: ValidationSummary } {
    const errors: ValidationError[] = [];

    console.log("Running comprehensive validation with 12 advanced rules...");

    // Core entity validations (Rules 1-5)
    errors.push(...this.validateClients());
    errors.push(...this.validateWorkers());
    errors.push(...this.validateTasks());

    // Advanced cross-entity validations (Rules 6-12)
    errors.push(...this.validateCrossEntityReferences());
    errors.push(...this.validateCircularDependencies());
    errors.push(...this.validatePhaseSlotSaturation());
    errors.push(...this.validateSkillCoverageMatrix());
    errors.push(...this.validateMaxConcurrencyFeasibility());
    errors.push(...this.validateBusinessRuleConflicts());
    errors.push(...this.validateResourceAllocation());

    const summary = this.generateAdvancedSummary(errors);

    console.log(`âœ… Validation complete: ${errors.length} issues found`);
    console.log(`ðŸ“Š Validation Score: ${summary.validationScore}/100`);

    return { errors, summary };
  }

  // RULE 1-2: Missing required columns & Duplicate IDs
  private validateClients(): ValidationError[] {
    const errors: ValidationError[] = [];
    const clientIds = new Set<string>();
    const requiredColumns = ["ClientId", "ClientName", "PriorityLevel"];

    this.clients.forEach((client, index) => {
      // Required columns check
      requiredColumns.forEach((column) => {
        if (!client[column as keyof Client]) {
          errors.push({
            row: index,
            column,
            message: `Required column "${column}" is missing or empty`,
            type: "critical",
            entityType: "client",
            severity: 5,
          });
        }
      });

      // Duplicate ID check
      if (client.ClientId) {
        if (clientIds.has(client.ClientId)) {
          errors.push({
            row: index,
            column: "ClientId",
            message: `Duplicate ClientID "${client.ClientId}" found`,
            type: "critical",
            entityType: "client",
            severity: 5,
          });
        } else {
          clientIds.add(client.ClientId);
        }
      }

      // RULE 4: Out-of-range values (PriorityLevel 1-5)
      if (
        client.PriorityLevel &&
        (client.PriorityLevel < 1 || client.PriorityLevel > 5)
      ) {
        errors.push({
          row: index,
          column: "PriorityLevel",
          message: `PriorityLevel must be between 1 and 5, got ${client.PriorityLevel}`,
          type: "error",
          entityType: "client",
          severity: 3,
        });
      }

      // RULE 5: Broken JSON in AttributesJSON
      if (client.AttributesJSON) {
        try {
          JSON.parse(client.AttributesJSON);
        } catch (jsonError) {
          errors.push({
            row: index,
            column: "AttributesJSON",
            message: "Invalid JSON format in AttributesJSON",
            type: "error",
            entityType: "client",
            severity: 3,
          });
        }
      }

      // RULE 3: Malformed lists (RequestedTaskIDs)
      if (client.RequestedTaskIDs && !Array.isArray(client.RequestedTaskIDs)) {
        errors.push({
          row: index,
          column: "RequestedTaskIDs",
          message: "RequestedTaskIDs must be an array",
          type: "error",
          entityType: "client",
          severity: 3,
        });
      }
    });

    return errors;
  }

  private validateWorkers(): ValidationError[] {
    const errors: ValidationError[] = [];
    const workerIds = new Set<string>();
    const requiredColumns = [
      "WorkerID",
      "WorkerName",
      "Skills",
      "AvailableSlots",
      "MaxLoadPerPhase",
    ];

    this.workers.forEach((worker, index) => {
      // Required columns check
      requiredColumns.forEach((column) => {
        if (!worker[column as keyof WorkerData]) {
          errors.push({
            row: index,
            column,
            message: `Required column "${column}" is missing or empty`,
            type: "critical",
            entityType: "worker",
            severity: 5,
          });
        }
      });

      // Duplicate ID check
      if (worker.WorkerID) {
        if (workerIds.has(worker.WorkerID)) {
          errors.push({
            row: index,
            column: "WorkerID",
            message: `Duplicate WorkerID "${worker.WorkerID}" found`,
            type: "critical",
            entityType: "worker",
            severity: 5,
          });
        } else {
          workerIds.add(worker.WorkerID);
        }
      }

      // RULE 3: Malformed lists (AvailableSlots must be numeric)
      const availableSlots = Array.isArray(worker.AvailableSlots)
        ? worker.AvailableSlots
        : [];
      if (
        availableSlots.some(
          (slot: any) => isNaN(Number(slot)) || Number(slot) < 1
        )
      ) {
        errors.push({
          row: index,
          column: "AvailableSlots",
          message: "AvailableSlots must contain valid positive numbers only",
          type: "error",
          entityType: "worker",
          severity: 4,
        });
      }

      // RULE 9: Overloaded workers (AvailableSlots.length < MaxLoadPerPhase)
      if (
        availableSlots.length > 0 &&
        worker.MaxLoadPerPhase > availableSlots.length
      ) {
        errors.push({
          row: index,
          column: "MaxLoadPerPhase",
          message: `MaxLoadPerPhase (${worker.MaxLoadPerPhase}) cannot exceed AvailableSlots count (${availableSlots.length})`,
          type: "error",
          entityType: "worker",
          severity: 4,
        });
      }

      // Qualification level validation
      if (
        worker.QualificationLevel &&
        (worker.QualificationLevel < 1 || worker.QualificationLevel > 10)
      ) {
        errors.push({
          row: index,
          column: "QualificationLevel",
          message: "QualificationLevel must be between 1 and 10",
          type: "warning",
          entityType: "worker",
          severity: 2,
        });
      }
    });

    return errors;
  }

  private validateTasks(): ValidationError[] {
    const errors: ValidationError[] = [];
    const taskIds = new Set<string>();
    const requiredColumns = [
      "TaskID",
      "TaskName",
      "Duration",
      "RequiredSkills",
    ];

    this.tasks.forEach((task, index) => {
      // Required columns check
      requiredColumns.forEach((column) => {
        if (!task[column as keyof Task]) {
          errors.push({
            row: index,
            column,
            message: `Required column "${column}" is missing or empty`,
            type: "critical",
            entityType: "task",
            severity: 5,
          });
        }
      });

      // Duplicate ID check
      if (task.TaskID) {
        if (taskIds.has(task.TaskID)) {
          errors.push({
            row: index,
            column: "TaskID",
            message: `Duplicate TaskID "${task.TaskID}" found`,
            type: "critical",
            entityType: "task",
            severity: 5,
          });
        } else {
          taskIds.add(task.TaskID);
        }
      }

      // RULE 4: Out-of-range values (Duration < 1)
      if (task.Duration && task.Duration < 1) {
        errors.push({
          row: index,
          column: "Duration",
          message: `Duration must be at least 1, got ${task.Duration}`,
          type: "error",
          entityType: "task",
          severity: 4,
        });
      }

      // MaxConcurrent validation
      if (task.MaxConcurrent && task.MaxConcurrent < 1) {
        errors.push({
          row: index,
          column: "MaxConcurrent",
          message: "MaxConcurrent must be at least 1",
          type: "error",
          entityType: "task",
          severity: 3,
        });
      }

      // RULE 3: Malformed lists validation
      if (task.RequiredSkills && !Array.isArray(task.RequiredSkills)) {
        errors.push({
          row: index,
          column: "RequiredSkills",
          message: "RequiredSkills must be an array",
          type: "error",
          entityType: "task",
          severity: 3,
        });
      }

      if (task.PreferredPhases && !Array.isArray(task.PreferredPhases)) {
        errors.push({
          row: index,
          column: "PreferredPhases",
          message: "PreferredPhases must be an array",
          type: "error",
          entityType: "task",
          severity: 3,
        });
      }
    });

    return errors;
  }

  // RULE 6: Unknown references (RequestedTaskIDs not in tasks; regex rules referencing missing TaskIDs)
  // private validateCrossEntityReferences(): ValidationError[] {
  //     const errors: ValidationError[] = [];
  //     const taskIds = new Set(this.tasks.map(t => t.TaskID).filter(Boolean));

  //     // Check client RequestedTaskIDs references
  //     this.clients.forEach((client, index) => {
  //         const requestedTaskIDs = Array.isArray(client.RequestedTaskIDs) ? client.RequestedTaskIDs : [];

  //         requestedTaskIDs.forEach((taskId: string) => {
  //             if (taskId && !taskIds.has(taskId)) {
  //                 errors.push({
  //                     row: index,
  //                     column: 'RequestedTaskIDs',
  //                     message: `Referenced TaskID "${taskId}" not found in tasks dataset`,
  //                     type: 'error',
  //                     entityType: 'client',
  //                     severity: 4
  //                 });
  //             }
  //         });
  //     });

  //     // Check task dependencies references
  //     this.tasks.forEach((task, index) => {
  //         if (task.Dependencies && Array.isArray(task.Dependencies)) {
  //             task.Dependencies.forEach((depTaskId: string) => {
  //                 if (depTaskId && !taskIds.has(depTaskId)) {
  //                     errors.push({
  //                         row: index,
  //                         column: 'Dependencies',
  //                         message: `Dependency TaskID "${depTaskId}" not found in tasks dataset`,
  //                         type: 'error',
  //                         entityType: 'task',
  //                         severity: 4
  //                     });
  //                 }
  //             });
  //         }
  //     });

  //     return errors;
  // }
  private validateCrossEntityReferences(): ValidationError[] {
    const errors: ValidationError[] = [];
    const taskIds = new Set(this.tasks.map((t) => t.TaskID));

    // Clients â†’ Tasks
    this.clients.forEach((client, row) => {
      (client.RequestedTaskIDs || []) // guard missing / empty
        .filter((id) => !taskIds.has(id))
        .forEach((id) => {
          errors.push({
            row,
            column: "RequestedTaskIDs",
            message: `Task "${id}" not found`,
            type: "error",
            entityType: "client",
            severity: 4,
          });
        });
    });

    // Tasks â†’ Dependencies
    this.tasks.forEach((task, row) => {
      (task.Dependencies || [])
        .filter((dep) => !taskIds.has(dep))
        .forEach((badDep) => {
          errors.push({
            row,
            column: "Dependencies",
            message: `Dependency "${badDep}" not found`,
            type: "error",
            entityType: "task",
            severity: 4,
          });
        });
    });

    return errors;
  }

  // RULE 7: Circular co-run groups (Aâ†’Bâ†’Câ†’A)
  private validateCircularDependencies(): ValidationError[] {
    const errors: ValidationError[] = [];

    // Build dependency graph
    const dependencyGraph: Map<string, string[]> = new Map();

    this.tasks.forEach((task) => {
      if (
        task.TaskID &&
        task.Dependencies &&
        Array.isArray(task.Dependencies)
      ) {
        dependencyGraph.set(task.TaskID, task.Dependencies.filter(Boolean));
      }
    });

    // Detect circular dependencies using DFS
    const visiting = new Set<string>();
    const visited = new Set<string>();

    const detectCycle = (taskId: string, path: string[]): boolean => {
      if (visiting.has(taskId)) {
        // Found a cycle
        const cycleStart = path.indexOf(taskId);
        const cycle = [...path.slice(cycleStart), taskId];

        const taskIndex = this.tasks.findIndex((t) => t.TaskID === taskId);
        errors.push({
          row: taskIndex,
          column: "Dependencies",
          message: `Circular dependency detected: ${cycle.join(" â†’ ")}`,
          type: "critical",
          entityType: "task",
          severity: 5,
        });
        return true;
      }

      if (visited.has(taskId)) return false;

      visiting.add(taskId);
      const dependencies = dependencyGraph.get(taskId) || [];

      for (const depId of dependencies) {
        if (detectCycle(depId, [...path, taskId])) {
          return true;
        }
      }

      visiting.delete(taskId);
      visited.add(taskId);
      return false;
    };

    // Check each task for circular dependencies
    for (const taskId of dependencyGraph.keys()) {
      if (!visited.has(taskId)) {
        detectCycle(taskId, []);
      }
    }

    return errors;
  }

  // RULE 8: Conflicting rules vs. phase-window constraints
  private validateBusinessRuleConflicts(): ValidationError[] {
    const errors: ValidationError[] = [];

    // Check for phase conflicts
    this.tasks.forEach((task, index) => {
      const preferredPhases = Array.isArray(task.PreferredPhases)
        ? task.PreferredPhases
        : [];
      const duration = task.Duration || 0;

      // Check if preferred phases can accommodate task duration
      if (preferredPhases.length > 0 && duration > 0) {
        const maxPhase = Math.max(...preferredPhases);
        const minPhase = Math.min(...preferredPhases);
        const phaseSpan = maxPhase - minPhase + 1;

        if (duration > phaseSpan) {
          errors.push({
            row: index,
            column: "PreferredPhases",
            message: `Task duration (${duration}) exceeds preferred phase span (${phaseSpan}). Phases: ${preferredPhases.join(
              ", "
            )}`,
            type: "warning",
            entityType: "task",
            severity: 3,
          });
        }
      }
    });

    // Check for worker availability conflicts
    this.workers.forEach((worker, index) => {
      const availableSlots = Array.isArray(worker.AvailableSlots)
        ? worker.AvailableSlots
        : [];
      const maxLoad = worker.MaxLoadPerPhase;

      // Check if any phase would be overloaded based on current task assignments
      availableSlots.forEach((phase: number) => {
        if (typeof phase === "number") {
          const potentialLoad = this.tasks.filter((task) => {
            const preferredPhases = Array.isArray(task.PreferredPhases)
              ? task.PreferredPhases
              : [];
            return preferredPhases.includes(phase);
          }).length;

          if (potentialLoad > maxLoad) {
            errors.push({
              row: index,
              column: "MaxLoadPerPhase",
              message: `Worker "${worker.WorkerID}" may be overloaded in phase ${phase}: ${potentialLoad} potential tasks vs ${maxLoad} max load`,
              type: "warning",
              entityType: "worker",
              severity: 2,
            });
          }
        }
      });
    });

    return errors;
  }

  // RULE 10: Phase-slot saturation: sum of task durations per Phase â‰¤ total worker slots
  private validatePhaseSlotSaturation(): ValidationError[] {
    const errors: ValidationError[] = [];

    // Calculate total available slots per phase
    const phaseCapacity: Map<number, number> = new Map();

    this.workers.forEach((worker) => {
      const availableSlots = Array.isArray(worker.AvailableSlots)
        ? worker.AvailableSlots
        : [];
      availableSlots.forEach((phase: number) => {
        if (typeof phase === "number" && phase > 0) {
          phaseCapacity.set(
            phase,
            (phaseCapacity.get(phase) || 0) + worker.MaxLoadPerPhase
          );
        }
      });
    });

    // Calculate required capacity per phase
    const phaseRequirements: Map<
      number,
      { totalDuration: number; tasks: string[] }
    > = new Map();

    this.tasks.forEach((task, index) => {
      const preferredPhases = Array.isArray(task.PreferredPhases)
        ? task.PreferredPhases
        : [];
      const duration = task.Duration || 0;

      if (duration > 0 && preferredPhases.length > 0) {
        // Distribute task duration across preferred phases
        const durationPerPhase = duration / preferredPhases.length;

        preferredPhases.forEach((phase: number) => {
          if (typeof phase === "number" && phase > 0) {
            const current = phaseRequirements.get(phase) || {
              totalDuration: 0,
              tasks: [],
            };
            current.totalDuration += durationPerPhase;
            current.tasks.push(task.TaskID || `Task-${index}`);
            phaseRequirements.set(phase, current);
          }
        });
      }
    });

    // Check for oversaturation
    for (const [phase, requirements] of phaseRequirements) {
      const capacity = phaseCapacity.get(phase) || 0;

      if (requirements.totalDuration > capacity) {
        errors.push({
          row: -1,
          column: "Phase Planning",
          message: `Phase ${phase} oversaturated: requires ${requirements.totalDuration.toFixed(
            1
          )} slots but only ${capacity} available. Tasks: ${requirements.tasks.join(
            ", "
          )}`,
          type: "critical",
          entityType: "system",
          severity: 5,
        });
      }
    }

    return errors;
  }

  // RULE 11: Skill-coverage matrix: every RequiredSkill maps to â‰¥1 worker
  private validateSkillCoverageMatrix(): ValidationError[] {
    const errors: ValidationError[] = [];

    // Build worker skills map
    const availableSkills = new Set<string>();
    const skillWorkerMap: Map<string, string[]> = new Map();

    this.workers.forEach((worker) => {
      const skills = Array.isArray(worker.Skills) ? worker.Skills : [];
      skills.forEach((skill: string) => {
        if (skill) {
          availableSkills.add(skill);
          const workers = skillWorkerMap.get(skill) || [];
          workers.push(worker.WorkerID || "Unknown");
          skillWorkerMap.set(skill, workers);
        }
      });
    });

    // Check task requirements
    this.tasks.forEach((task, index) => {
      const requiredSkills = Array.isArray(task.RequiredSkills)
        ? task.RequiredSkills
        : [];

      requiredSkills.forEach((skill: string) => {
        if (skill && !availableSkills.has(skill)) {
          errors.push({
            row: index,
            column: "RequiredSkills",
            message: `No worker has required skill "${skill}" for task "${
              task.TaskID || "Unknown"
            }"`,
            type: "critical",
            entityType: "task",
            severity: 5,
          });
        } else if (skill) {
          const workers = skillWorkerMap.get(skill) || [];
          if (workers.length === 1) {
            errors.push({
              row: index,
              column: "RequiredSkills",
              message: `Only one worker (${workers[0]}) has skill "${skill}" - potential bottleneck`,
              type: "warning",
              entityType: "task",
              severity: 2,
            });
          }
        }
      });
    });

    return errors;
  }

  // RULE 12: Max-concurrency feasibility: MaxConcurrent â‰¤ count of qualified, available workers
  private validateMaxConcurrencyFeasibility(): ValidationError[] {
    const errors: ValidationError[] = [];

    // Build skill-to-workers mapping
    const skillToWorkers: Map<string, WorkerData[]> = new Map();

    this.workers.forEach((worker) => {
      const skills = Array.isArray(worker.Skills) ? worker.Skills : [];
      skills.forEach((skill: string) => {
        if (skill) {
          const workers = skillToWorkers.get(skill) || [];
          workers.push(worker);
          skillToWorkers.set(skill, workers);
        }
      });
    });

    this.tasks.forEach((task, index) => {
      const requiredSkills = Array.isArray(task.RequiredSkills)
        ? task.RequiredSkills
        : [];
      const maxConcurrent = task.MaxConcurrent || 1;

      if (requiredSkills.length > 0) {
        // Find workers who have ALL required skills
        let qualifiedWorkers = new Set(this.workers);

        requiredSkills.forEach((skill: string) => {
          if (skill) {
            const workersWithSkill = new Set(skillToWorkers.get(skill) || []);
            qualifiedWorkers = new Set(
              [...qualifiedWorkers].filter((w) => workersWithSkill.has(w))
            );
          }
        });

        const qualifiedCount = qualifiedWorkers.size;

        if (maxConcurrent > qualifiedCount) {
          errors.push({
            row: index,
            column: "MaxConcurrent",
            message: `MaxConcurrent (${maxConcurrent}) exceeds qualified workers (${qualifiedCount}) for task "${
              task.TaskID
            }". Required skills: ${requiredSkills.join(", ")}`,
            type: "error",
            entityType: "task",
            severity: 4,
          });
        }
      }
    });

    return errors;
  }

  // Additional validation for resource allocation
  private validateResourceAllocation(): ValidationError[] {
    const errors: ValidationError[] = [];

    // Check overall system capacity
    const totalWorkerCapacity = this.workers.reduce((sum, worker) => {
      const slots = Array.isArray(worker.AvailableSlots)
        ? worker.AvailableSlots.length
        : 0;
      return sum + slots * worker.MaxLoadPerPhase;
    }, 0);

    const totalTaskLoad = this.tasks.reduce((sum, task) => {
      return sum + (task.Duration || 0) * (task.MaxConcurrent || 1);
    }, 0);

    if (totalTaskLoad > totalWorkerCapacity * 0.9) {
      // 90% threshold
      errors.push({
        row: -1,
        column: "System Capacity",
        message: `System approaching capacity limits: ${totalTaskLoad} task-load vs ${totalWorkerCapacity} worker-capacity`,
        type: "warning",
        entityType: "system",
        severity: 3,
      });
    }

    return errors;
  }

  private generateAdvancedSummary(
    errors: ValidationError[]
  ): ValidationSummary {
    const criticalCount = errors.filter((e) => e.type === "critical").length;
    const errorCount = errors.filter((e) => e.type === "error").length;
    const warningCount = errors.filter((e) => e.type === "warning").length;

    // Calculate validation score (0-100)
    const totalDataPoints =
      this.clients.length + this.workers.length + this.tasks.length;
    const maxPossibleIssues = totalDataPoints * 3; // Assume max 3 issues per data point
    const actualIssues = criticalCount * 3 + errorCount * 2 + warningCount * 1; // Weighted
    const validationScore = Math.max(
      0,
      Math.round(100 - (actualIssues / maxPossibleIssues) * 100)
    );

    const summary: ValidationSummary = {
      totalErrors: errorCount,
      totalWarnings: warningCount,
      totalCritical: criticalCount,
      errorsByEntity: {},
      errorsByType: {
        critical: criticalCount,
        error: errorCount,
        warning: warningCount,
      },
      validationScore,
      canProceed: criticalCount === 0 && errorCount < 5, // System can proceed if no critical errors and few errors
    };

    // Count by entity
    errors.forEach((error) => {
      summary.errorsByEntity[error.entityType] =
        (summary.errorsByEntity[error.entityType] || 0) + 1;
    });

    return summary;
  }
}
